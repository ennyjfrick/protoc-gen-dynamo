package pgd

import (
	"bytes"
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
	"github.com/pquerna/protoc-gen-dynamo/internal/pb/dynamopb"
)

const (
	moduleName    = "dynamo"
	version       = "0.1.0"
	commentFormat = `// Code generated by protoc-gen-%s v%s. DO NOT EDIT.
// source: %s
`
)

type Module struct {
	*pgs.ModuleBase
	ctx pgsgo.Context
}

var _ pgs.Module = (*Module)(nil)

func New() pgs.Module {
	return &Module{ModuleBase: &pgs.ModuleBase{}}
}

func (m *Module) InitContext(ctx pgs.BuildContext) {
	m.ModuleBase.InitContext(ctx)
	m.ctx = pgsgo.InitContext(ctx.Parameters())
}

func (m *Module) Name() string {
	return moduleName
}

func (m *Module) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	for _, f := range targets {
		msgs := f.AllMessages()
		if n := len(msgs); n == 0 {
			m.Debugf("No messagess in %v, skipping", f.Name())
			continue
		}
		m.processFile(f)
	}
	return m.Artifacts()
}

func (m *Module) processFile(f pgs.File) {
	out := bytes.Buffer{}
	err := m.applyTemplate(&out, f)
	if err != nil {
		m.Logf("couldn't apply template: %s", err)
		m.Fail("code generation failed")
	} else {
		generatedFileName := m.ctx.OutputPath(f).SetExt(fmt.Sprintf(".%s.go", moduleName)).String()
		m.AddGeneratorFile(generatedFileName, out.String())
	}
}

const (
	dynamoPkg  = "github.com/aws/aws-sdk-go/service/dynamodb"
	awsPkg     = "github.com/aws/aws-sdk-go/aws"
	strconvPkg = "strconv"
)

func (m *Module) applyTemplate(buf *bytes.Buffer, in pgs.File) error {
	pkgName := m.ctx.PackageName(in).String()
	importPath := m.ctx.ImportPath(in).String()
	protoFileName := in.Name().String()

	f := jen.NewFilePathName(importPath, pkgName)
	f.HeaderComment(fmt.Sprintf(commentFormat, moduleName, version, protoFileName))

	f.ImportName(dynamoPkg, "dynamodb")
	f.ImportName(awsPkg, "aws")
	f.ImportName(strconvPkg, "strconv")

	// https://godoc.org/github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute#Marshaler
	// https://godoc.org/github.com/guregu/dynamo#Marshaler
	err := m.applyMarshal(f, in)
	if err != nil {
		return err
	}

	// https://godoc.org/github.com/guregu/dynamo#Unmarshaler
	// UnmarshalDynamo(av *dynamodb.AttributeValue) error
	err = m.applyUnmarshal(f, in)
	if err != nil {
		return err
	}

	return f.Render(buf)
}

type avType string

const (
	avt_bytes      avType = "B"
	avt_bool       avType = "BOOL"
	avt_byte_set   avType = "BS"
	avt_list       avType = "L"
	avt_map        avType = "M"
	avt_number     avType = "N"
	avt_number_set avType = "NS"
	avt_null       avType = "NULL"
	avt_string     avType = "S"
	avt_string_set avType = "SS"
)

func getAVType(field pgs.Field, fext *dynamopb.DynamoFieldOptions) avType {
	isArray := field.Type().ProtoLabel() == pgs.Repeated
	pt := field.Type().ProtoType()

	if isArray {
		if !fext.Type.Set {
			return avt_list
		}
		switch {
		case pt.IsInt() || pt == pgs.DoubleT || pt == pgs.FloatT:
			return avt_number_set
		case pt == pgs.StringT:
			return avt_string_set
		case pt == pgs.BytesT:
			return avt_byte_set
		case pt == pgs.EnumT:
			return avt_number_set
		}
	} else {
		switch {
		case pt.IsInt() || pt == pgs.DoubleT || pt == pgs.FloatT:
			return avt_number
		case pt == pgs.BoolT:
			return avt_bool
		case pt == pgs.StringT:
			return avt_string
		case pt == pgs.BytesT:
			return avt_bytes
		case pt == pgs.MessageT:
			return avt_map
		case pt == pgs.EnumT:
			return avt_number
		}
	}
	panic(fmt.Sprintf("getAVType: failed to determine dynamodb type: %T %+v", field, fext.Type))
}

func (m *Module) applyMarshal(f *jen.File, in pgs.File) error {
	for _, msg := range in.AllMessages() {
		structName := m.ctx.Name(msg)
		mext := dynamopb.DynamoMessageOptions{}
		ok, err := msg.Extension(dynamopb.E_Msg, &mext)
		if err != nil {
			m.Logf("Parsing dynamo.msg.disabled failed: %s", err)
			m.Fail("code generation failed")
		}
		if ok && mext.Disabled {
			m.Logf("dynamo.msg disabled for %s", structName)
			continue
		}
		// https://godoc.org/github.com/guregu/dynamo#Marshaler:
		// MarshalDynamo() (*dynamodb.AttributeValue, error)
		f.Func().Params(
			jen.Id("p").Op("*").Id(structName.String()),
		).Id("MarshalDynamo").Params().List(jen.Params(jen.Op("*").Qual(dynamoPkg, "AttributeValue"), jen.Id("error"))).Block(
			jen.Id("av").Op(":=").Op("&").Qual(dynamoPkg, "AttributeValue").Values(),
			jen.Id("err").Op(":=").Id("p").Dot("MarshalDynamoDBAttributeValue").Call(jen.Id("av")),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Id("err")),
			),
			jen.Return(jen.Id("av"), jen.Nil()),
		)

		stmts := []jen.Code{}
		refId := 0
		d := jen.Dict{}
		needNullBoolTrue := false
		for _, field := range msg.Fields() {
			fext := dynamopb.DynamoFieldOptions{}
			ok, err := field.Extension(dynamopb.E_Field, &fext)
			if err != nil {
				m.Failf("Error: Parsing dynamo.field failed for '%s': %s", field.FullyQualifiedName(), err)
			}
			if ok && fext.Skip {
				m.Logf("dynamo.field.skip: skipped %s", field.FullyQualifiedName())
				continue
			}
			if fext.Type == nil {
				fext.Type = &dynamopb.Types{}
			}
			if fext.Type.Binary {
				// TOOD(impl)
				// special case: store whole field as protobuf marshled force binary encoded
			}

			pt := field.Type().ProtoType()

			srcName := field.Name().UpperCamelCase().String()
			refId++
			vname := fmt.Sprintf("v%d", refId)
			arrix := fmt.Sprintf("ix%d", refId)
			arrname := fmt.Sprintf("arr%d", refId)
			isArray := field.Type().ProtoLabel() == pgs.Repeated
			if fext.Type.Set && !isArray {
				m.Failf("Error: dynamo.field.set=true, but field is not repeated / array type: '%s'.IsRepeated=%v",
					field.FullyQualifiedName(), field.Type().IsRepeated())
			}

			avt := getAVType(field, &fext)
			switch avt {
			case avt_bytes:
				needNullBoolTrue = true
				stmts = append(stmts, jen.Id(vname).Op(":=").Op("&").Qual(dynamoPkg, "AttributeValue").Values())
				stmts = append(stmts,
					jen.If(jen.Len(jen.Id("p").Dot(field.Name().UpperCamelCase().String())).Op("!=").Lit(0)).Block(
						jen.Id(vname).Dot("B").Op("=").Id("p").Dot(srcName),
					).Else().Block(
						jen.Id(vname).Dot("NULL").Op("=").Op("&").Id("nullBoolTrue"),
					),
				)
				d[jen.Lit(field.Name().LowerSnakeCase().String())] = jen.Id(vname)
			case avt_bool:
				d[jen.Lit(field.Name().LowerSnakeCase().String())] = jen.Op("&").Qual(dynamoPkg, "AttributeValue").Values(jen.Dict{
					jen.Id("BOOL"): jen.Op("&").Id("p").Dot(srcName),
				})
			case avt_list:
				stmts = append(stmts,
					jen.Id(arrname).Op(":=").Make(
						jen.Op("[]*").Qual(dynamoPkg, "AttributeValue"),
						jen.Lit(0),
						jen.Len(jen.Id("p").Dot(srcName)),
					),
				)

				switch {
				case pt.IsInt() || pt == pgs.DoubleT || pt == pgs.FloatT:
					fmtCall := numberFormatStatement(pt, jen.Id(arrix))
					stmts = append(stmts,
						jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot(srcName)).Block(
							jen.Id(arrname).Op("=").Append(
								jen.Id(arrname),
								jen.Op("&").Qual(dynamoPkg, "AttributeValue").Values(jen.Dict{
									jen.Id("N"): jen.Qual(awsPkg, "String").Call(
										fmtCall,
									),
								}),
							),
						),
					)
				case pt == pgs.StringT:
					stmts = append(stmts,
						jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot(srcName)).Block(
							jen.Id(arrname).Op("=").Append(
								jen.Id(arrname),
								jen.Op("&").Qual(dynamoPkg, "AttributeValue").Values(jen.Dict{
									jen.Id("S"): jen.Qual(awsPkg, "String").Call(
										jen.Id(arrix),
									),
								}),
							),
						),
					)
				default:
					m.Failf("Error: dynamo.field '%s' is repeated, but the '%s' type is not supported", field.FullyQualifiedName(), pt.String())
				}
				d[jen.Lit(field.Name().LowerSnakeCase().String())] = jen.Op("&").Qual(dynamoPkg, "AttributeValue").Values(jen.Dict{
					jen.Id("L"): jen.Id(arrname),
				})
			case avt_map:
				// avt_map: impl
				panic("not done")
			case avt_number:
				fmtCall := numberFormatStatement(pt, jen.Id("p").Dot(srcName))
				d[jen.Lit(field.Name().LowerSnakeCase().String())] = jen.Op("&").Qual(dynamoPkg, "AttributeValue").Values(jen.Dict{
					jen.Id("N"): jen.Qual(awsPkg, "String").Call(fmtCall),
				})
			case avt_null:
				// avt_null: unused
			case avt_string:
				needNullBoolTrue = true
				stmts = append(stmts, jen.Id(vname).Op(":=").Op("&").Qual(dynamoPkg, "AttributeValue").Values())
				stmts = append(stmts,
					jen.If(jen.Len(jen.Id("p").Dot(field.Name().UpperCamelCase().String())).Op("!=").Lit(0)).Block(
						jen.Id(vname).Dot("S").Op("=").Qual(awsPkg, "String").Call(jen.Id("p").Dot(srcName)),
					).Else().Block(
						jen.Id(vname).Dot("NULL").Op("=").Op("&").Id("nullBoolTrue"),
					),
				)
				d[jen.Lit(field.Name().LowerSnakeCase().String())] = jen.Id(vname)
			case avt_string_set, avt_number_set, avt_byte_set:
				stmts = append(stmts,
					jen.Id(arrname).Op(":=").Make(
						jen.Op("[]*").Id("string"),
						jen.Lit(0),
						jen.Len(jen.Id("p").Dot(srcName)),
					),
				)
				needNullBoolTrue = true
				setType := ""
				switch avt {
				case avt_number_set:
					setType = "NS"
					fmtCall := numberFormatStatement(pt, jen.Id(arrix))
					stmts = append(stmts,
						jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot(srcName)).Block(
							jen.Id(arrname).Op("=").Append(
								jen.Id(arrname),
								jen.Qual(awsPkg, "String").Call(
									fmtCall,
								),
							),
						),
					)
				case avt_string_set:
					setType = "SS"
					stmts = append(stmts,
						jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot(srcName)).Block(
							jen.Id(arrname).Op("=").Append(
								jen.Id(arrname),
								jen.Qual(awsPkg, "String").Call(
									jen.Id(arrix),
								),
							),
						),
					)
				case avt_byte_set:
					setType = "BS"
					stmts = append(stmts,
						jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot(srcName)).Block(
							jen.Id(arrname).Op("=").Append(
								jen.Id(arrname),
								jen.Id(arrix),
							),
						),
					)
				}

				stmts = append(stmts,
					jen.Var().Id(vname).Op("*").Qual(dynamoPkg, "AttributeValue"),
					jen.If(jen.Len(jen.Id(arrname)).Op("!=").Lit(0)).Block(
						jen.Id(vname).Op("=").Op("&").Qual(dynamoPkg, "AttributeValue").Values(jen.Dict{
							jen.Id(setType): jen.Id(arrname),
						}),
					).Else().Block(
						jen.Id(vname).Dot("NULL").Op("=").Op("&").Id("nullBoolTrue"),
					),
				)
				d[jen.Lit(field.Name().LowerSnakeCase().String())] = jen.Id(vname)
			}
		}

		if needNullBoolTrue {
			stmts = append([]jen.Code{
				jen.Id("nullBoolTrue").Op(":=").True(),
			}, stmts...)
		}

		stmts = append(stmts, jen.Id("av").Dot("M").Op("=").Map(jen.String()).Op("*").Qual(dynamoPkg, "AttributeValue").Values(d))

		stmts = append(stmts, jen.Return(jen.Nil()))
		f.Func().Params(
			jen.Id("p").Op("*").Id(structName.String()),
		).Id("MarshalDynamoDBAttributeValue").Params(jen.Id("av").Op("*").Qual(dynamoPkg, "AttributeValue")).Id("error").Block(
			stmts...,
		)
	}
	return nil
}

func (m *Module) applyUnmarshal(f *jen.File, in pgs.File) error {
	for _, msg := range in.AllMessages() {
		structName := m.ctx.Name(msg)
		mext := dynamopb.DynamoMessageOptions{}
		ok, err := msg.Extension(dynamopb.E_Msg, &mext)
		if err != nil {
			m.Logf("Parsing dynamo.msg failed: %s", err)
			m.Fail("code generation failed")
		}
		if ok && mext.Disabled {
			m.Logf("dynamo.msg disabled for %s", structName)
			continue
		}

		stmts := []jen.Code{}
		loop := []jen.Code{}
		for _, field := range msg.Fields() {
			fext := dynamopb.DynamoFieldOptions{}
			ok, err := field.Extension(dynamopb.E_Field, &fext)
			if err != nil {
				m.Failf("Error: Parsing dynamo.field failed for '%s': %s", field.FullyQualifiedName(), err)
			}
			if ok && fext.Skip {
				m.Logf("dynamo.field.skip: skipped %s", field.FullyQualifiedName())
				continue
			}
			if fext.Type == nil {
				fext.Type = &dynamopb.Types{}
			}
			unm := []jen.Code{}

			avt := getAVType(field, &fext)
			switch avt {
			case
			}
			loop = append(loop, jen.Case(jen.Lit(field.Name().LowerSnakeCase().String())).Block(
				unm...,
			))
		}

		stmts = append(stmts,
			jen.For(jen.List(jen.Id("key"), jen.Id("value")).Op(":=").Range().Id("av").Dot("M")).Block(
				jen.Switch(jen.Id("key")).Block(
					loop...,
				),
			),
		)

		stmts = append(stmts, jen.Return(jen.Nil()))

		f.Func().Params(
			jen.Id("p").Op("*").Id(structName.String()),
		).Id("UnmarshalDynamoDBAttributeValue").Params(jen.Id("av").Op("*").Qual(dynamoPkg, "AttributeValue")).Id("error").Block(
			stmts...,
		)

		f.Func().Params(
			jen.Id("p").Op("*").Id(structName.String()),
		).Id("UnmarshalDynamo").Params(jen.Id("av").Op("*").Qual(dynamoPkg, "AttributeValue")).Id("error").Block(
			jen.Return(jen.Id("p").Dot("UnmarshalDynamoDBAttributeValue").Call(jen.Id("av"))),
		)
	}
	return nil
}

func numberFormatStatement(pt pgs.ProtoType, access *jen.Statement) *jen.Statement {
	var rv *jen.Statement
	switch pt {
	case pgs.DoubleT, pgs.FloatT:
		rv = jen.Qual(strconvPkg, "FormatFloat").Call(
			jen.Id("float64").Call(access),
			jen.LitByte('E'),
			jen.Lit(-1),
			jen.Lit(64),
		)
	case pgs.Int64T, pgs.SFixed64, pgs.SInt64, pgs.Int32T, pgs.SFixed32, pgs.SInt32:
		rv = jen.Qual(strconvPkg, "FormatInt").Call(
			jen.Id("int64").Call(access),
			jen.Lit(10),
		)
	case pgs.UInt64T, pgs.Fixed64T, pgs.UInt32T, pgs.Fixed32T:
		rv = jen.Qual(strconvPkg, "FormatUint").Call(
			jen.Id("uint64").Call(access),
			jen.Lit(10),
		)
	}
	return rv
}
